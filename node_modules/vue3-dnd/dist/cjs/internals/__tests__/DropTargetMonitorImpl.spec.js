"use strict";
var _dropTargetMonitorImpl = require("../DropTargetMonitorImpl");
var _dndCore = require("dnd-core");
var _reactDndTestBackend = require("react-dnd-test-backend");
var _vitest = require("vitest");
(0, _vitest).describe("The DropTargetMonitorImpl", function() {
    (0, _vitest).it("can be constructed", function() {
        var manager = (0, _dndCore).createDragDropManager(_reactDndTestBackend.TestBackend);
        var monitor = new _dropTargetMonitorImpl.DropTargetMonitorImpl(manager);
        (0, _vitest).expect(monitor).toBeDefined();
    });
    (0, _vitest).it("uses the monitor for canDrop", function() {
        var canDropOnTarget = _vitest.vi.fn();
        var manager = (0, _dndCore).createDragDropManager(_reactDndTestBackend.TestBackend);
        manager.getMonitor().canDropOnTarget = canDropOnTarget;
        var monitor = new _dropTargetMonitorImpl.DropTargetMonitorImpl(manager);
        (0, _vitest).expect(monitor.canDrop()).toEqual(false);
        (0, _vitest).expect(canDropOnTarget.mock.calls).toHaveLength(0);
        monitor.receiveHandlerId("123");
        monitor.canDrop();
        (0, _vitest).expect(canDropOnTarget.mock.calls).toHaveLength(1);
        (0, _vitest).expect(canDropOnTarget.mock.calls[0]).toEqual([
            "123"
        ]);
    });
    (0, _vitest).it("throws if canDrop is used in a loop", function() {
        var manager = (0, _dndCore).createDragDropManager(_reactDndTestBackend.TestBackend);
        var monitor = new _dropTargetMonitorImpl.DropTargetMonitorImpl(manager);
        manager.getMonitor().canDropOnTarget = function() {
            return monitor.canDrop();
        };
        monitor.receiveHandlerId("123");
        (0, _vitest).expect(function() {
            return monitor.canDrop();
        }).toThrow("You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
    });
    (0, _vitest).it("uses the monitor for isOver", function() {
        var isOver = _vitest.vi.fn();
        var manager = (0, _dndCore).createDragDropManager(_reactDndTestBackend.TestBackend);
        manager.getMonitor().isOverTarget = isOver;
        var monitor = new _dropTargetMonitorImpl.DropTargetMonitorImpl(manager);
        (0, _vitest).expect(monitor.isOver()).toEqual(false);
        (0, _vitest).expect(isOver.mock.calls).toHaveLength(0);
        monitor.receiveHandlerId("123");
        monitor.isOver();
        (0, _vitest).expect(isOver.mock.calls).toHaveLength(1);
        (0, _vitest).expect(isOver.mock.calls[0]).toEqual([
            "123",
            undefined
        ]);
    });
    (0, _vitest).it("thunks to monitor methods", function() {
        var manager = (0, _dndCore).createDragDropManager(_reactDndTestBackend.TestBackend);
        var monitor = new _dropTargetMonitorImpl.DropTargetMonitorImpl(manager);
        var THUNK_METHODS = [
            "getItemType",
            "getItem",
            "getDropResult",
            "didDrop",
            "getInitialClientOffset",
            "getInitialSourceClientOffset",
            "getSourceClientOffset",
            "getClientOffset",
            "getDifferenceFromInitialOffset", 
        ];
        THUNK_METHODS.forEach(function(method) {
            var mock = _vitest.vi.fn();
            manager.getMonitor()[method] = mock;
            monitor[method]();
            (0, _vitest).expect(mock.mock.calls).toHaveLength(1);
        });
    });
});
